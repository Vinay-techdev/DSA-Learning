# ðŸ“˜ DSA Chapter 05 â€“ Sorting Algorithms

This chapter focuses on **sorting algorithms**, one of the most fundamental concepts in DSA. Sorting helps in **efficient searching, ranking, and organizing data**.

---

## ðŸ”¹ Algorithms Covered

1. **Selection Sort**  
   - Find the minimum element and place it at the correct position.  
   - Time Complexity: O(NÂ²)  

2. **Bubble Sort**  
   - Repeatedly swap adjacent elements if they are in the wrong order.  
   - Time Complexity: O(NÂ²)  

3. **Insertion Sort**  
   - Build the sorted array one element at a time.  
   - Time Complexity: O(NÂ²)  

4. **Bubble Sort (Recursive)**  
   - Bubble sort implemented using recursion.  

5. **Insertion Sort (Recursive)**  
   - Insertion sort implemented using recursion.  

6. **Merge Sort**  
   - Divide & conquer approach; merge sorted halves.  
   - Time Complexity: O(N log N)  

7. **Quick Sort**  
   - Divide & conquer; partition array around pivot.  
   - Time Complexity: O(N log N) (average)  

---

## ðŸ”‘ Key Takeaways

- **Recursive sorting** helps in understanding divide-and-conquer approaches.  
- **Merge Sort & Quick Sort** are efficient for large datasets.  
- Sorting is the **foundation for many advanced algorithms**.  

---

## ðŸš€ Next Steps

- Practice implementing each sort in **Java / C++**.  
- Solve **sorting-related problems** on LeetCode / GFG.  
- Compare **time and space complexity** of all sorting algorithms.